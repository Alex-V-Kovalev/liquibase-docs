<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head><title></title>
    </head>
    <body>
        <h1>Rule Stages and Objects</h1>
        <p />
        <div class="toc-macro client-side-toc-macro  conf-macro output-block">
        </div>
        <p>
            <br />
        </p>
        <p>Rules are placed in directories under the Rules directory for a project.&#160;</p>
        <div class="preformatted panel conf-macro output-block" style="border-width: 1px;">
            <div class="preformattedContent panelContent"><pre xml:space="preserve">&lt;project&gt;/
   Rules/
      Forecast/
      PostForecast/
      PreForecast/
      SqlRules/</pre>
            </div>
        </div>
        <h1 id="RuleStagesandObjects-DeploymentPackagerrules">Deployment Packager rules</h1>
        <ul>
            <li>SqlRules - applied by Deployment Packager during packaging of SQL scripts into changesets</li>
        </ul>
        <h1 id="RuleStagesandObjects-ForecastingRules">Forecasting Rules</h1>
        <p>Each directory corresponds to a phase in the forecasting process, where the impact of changesets is assessed against a target database before the changesets are deployed.&#160;</p>
        <ul>
            <li>PreForecast - applied immediately before a forecast</li>
            <li>Forecast - applied to produce a forecast of the impact of changes on the database schema</li>
            <li>PostForecast - applied to assess the results of a forecast and to perform further tests</li>
        </ul>
        <h1 id="RuleStagesandObjects-ObjectModelsAvailableforRules">Object Models Available for Rules</h1>
        <p>The available object data models vary by type of rule. See <a href="Data_Models_for_Rules.htm">Data Models for Rules</a>&#160;for a listing of objects available to rules.&#160;</p>
        <h2 id="RuleStagesandObjects-SqlRulesObjects">SqlRules Objects</h2>
        <p>The <strong>list of available models</strong> for the rules in this phase include:</p>
        <ul>
            <li>WithComments() - include comments in the SQL scripts during processing</li>
            <li>WithoutComments() - strip comments from the SQL scripts before processing</li>
        </ul>
        <h2 id="RuleStagesandObjects-PreForecastObjects">PreForecast Objects</h2>
        <p>The <strong>list of available models</strong> for the rules in this phase include:</p>
        <ul>
            <li>ClientSystemInfo()There is one of these objects available, and it has properties like the operating system version, the user name, and other aspects of the system that Datical DB is running on.</li>
            <li>Project()This is a model of the project itself, and includes properties including the project name. Some of the other properties available in the project (the list of databases, the changelog) are also exposed directly to the rules engine.</li>
            <li>ProjectResources()This is used to find the location of project resources files. It is required by the static getText() function.</li>
            <li>DatabaseDef()There may be multiple instances of this kind of object available, one for each database connection that is defined in the project. Each DatabaseDef will have properties like the name of the connection, the driver, the hostname, the username, and more.</li>
            <li>DatabaseChangeLog()This model comprises all of the changes that have ever been applied to the database as well as the changes that are about to be applied to the database.</li>
            <li>DbModel()This is a model of the target database at the time of the forecast.</li>
            <li>GeneratedSQL()This model has two properties – one contains all the SQL statements that would be applied for this update, and one contains all the SQL statements that would be included in a rollback of this update.</li>
            <li>ChangeSetType()There will be one of these objects for each change set that is about to be deployed – that is, only the change sets that have not already been deployed. This object is a model of the changeset, which has properties like the author, id, and file path, the list of contexts, the DBMS type, and a variety of others.</li>
        </ul>
        <h2 id="RuleStagesandObjects-ForecastObjects">Forecast Objects</h2>
        <p>The <strong>list of available models</strong> for the rules in this phase include:</p>
        <ul>
            <li>ClientSystemInfo()There is one of these objects available, and it has properties like the operating system version, the user name, and other aspects of the system that Datical DB is running on.</li>
            <li>Project()This is a model of the project itself, and includes properties including the project name. Some of the other properties available in the project (the list of databases, the changelog) are also exposed directly to the rules engine.</li>
            <li>ProjectResources()This is used to find the location of project resources files. It is required by the static getText() function.</li>
            <li>DatabaseDef() This DatabaseDef() is specific to the step that's being forecasted. The DatabaseDef has properties like the name of the connection, the driver, the hostname, the username, and more.</li>
            <li>DbModel()The DbModel is a container that is used during the simulation and forecast process. It can contain multiple Schema models (described below), a collection of messages that result from simulation and forecast operations, and a list of change set identifiers used to build the model.</li>
            <li>Schema() The Schema is the root object in a tree of objects representing the structure of the database including the tables, views, procedures, constraints, etc. Details on this object are documented later in this document. This object is also available as one of the Schema objects in the DbModel object, but is provided on its own for convenience.</li>
            <li>ChangeSetType() This object is a model of the changeset - a container for changes being made to a database that logically belong together. During the forecasting process, the rules engine is 'fired' once for every change that will be deployed to the database. Each change belongs to a changeset, which has properties like the author, id, and file path, the list of contexts, the DBMS type, and a variety of others.</li>
            <li>The ChangeRules in this phase have access to the objects that represent the actual change being made to the database. There are different objects for each of the different changes available, including things like AddTableType, DropTableType, etc. A full list of the different change types is included later in this document.</li>
        </ul>
        <h2 id="RuleStagesandObjects-PostForecastObjects">PostForecast Objects</h2>
        <p>The <strong>list of available models</strong> for the rules in this phase includes:</p>
        <ul>
            <li>ClientSystemInfo()There is one of these objects available, and it has properties like the operating system version, the user name, and other aspects of the system that Datical DB is running on.</li>
            <li>DatabaseDef()There may be multiple instances of this kind of object available, one for each database connection that is defined in the project. Each DatabaseDef will have properties like the name of the connection, the driver, the hostname, the username, and more.</li>
            <li>Project()This is a model of the project itself, and includes properties including the project name. Some of the other properties available in the project (the list of databases, the changelog) are also exposed directly to the rules engine.</li>
            <li>DatabaseChangeLog()This model comprises all of the changes that have ever been applied to the database as well as the changes that are about to be applied to the database.</li>
            <li>DbModel()The DbModel is a container that is used during the simulation and forecast process. It can contain multiple Schema models, a collection of messages that result from simulation and forecast operations, and a list of change set identifiers used to build the model. The DbModel that is available at the PostForecast stage contains the final model of the database schemas after all changes have been applied.</li>
            <li>ChangeSetType()This object is a model of the changeset - a container for changes being made to a database that logically belong together. During the post-forecast stage all of the changesets that were applied are available to the rules. Each changeset has properties like the author, id, and file path, the list of contexts, and the DBMS type.</li>
            <li>Forecast()This object is a model of the results of the Forecast operation. It is a complex object with nested objects.</li>
        </ul>
        <h1 id="RuleStagesandObjects-_Toc485899317RulePackages"><span class="confluence-anchor-link conf-macro output-inline" id="RuleStagesandObjects-_Toc485899317"></span>Rule Packages</h1>
        <p>Package names are used to define a namespace for your rules. Even though rules are in different files, using the same package name puts them in the same namespace.</p>
        <p>Initially, this gives you a way to group similar rules together. These groupings are available in the Datical DB rule package explorer to easily view groups of rules and find specific rules to work on.</p>
        <p>Suggested methods to package rules:</p>
        <p><code>package <strong><em>&lt;company&gt;.rules.&lt;rule execution phase&gt;</em></strong></code>
        </p>
        <p><code>package <strong><em>&lt;company&gt;.rules.&lt;rule execution phase&gt;.&lt;rule goal&gt;.&lt;rule db object&gt;</em></strong></code>
        </p>
        <ul>
            <li><strong>&lt;company&gt;:</strong> com.datical, com.americanexpress, com.wellsfargo, etc.</li>
            <li><strong>&lt;rule execution phase&gt;:</strong> PreForecast, Forecast, or PostForecast</li>
            <li><strong>&lt;rule goal&gt;:</strong> Access Control, Dependency Validation, Data Safety, <br />Corporate Standards, Audit and Compliance,</li>
            <li><strong>&lt;rule db object&gt;:</strong> group the rules by the primary object type we're writing the rule <br />about (Table, Column, Index, StoredProcedure, Trigger, etc)</li>
        </ul>
        <div class="confluence-information-macro confluence-information-macro-note conf-macro output-block">
            <p class="title">Avoid Duplicate Function Naming in Rule Packages</p>
            <div class="confluence-information-macro-body">
                <p>If custom functions are included in Rule definitions signatures for those functions should be unique to avoid overloading. A function's signature is derived from a function's name, argument and return type. Overloading functions can result in the wrong function being used when a rule is executed which could, in turn, negatively affect the outcome.&#160; Examples of matching and non-matching signatures are provided below.</p>
                <h3 id="RuleStagesandObjects-MatchingFunctionSignatureExample">Matching Function Signature Example</h3>
                <div class="code panel pdl conf-macro output-block" style="border-width: 1px;">
                    <div class="codeContent panelContent pdl"><pre class="syntaxhighlighter-pre" xml:space="preserve">function boolean containsSuspectString(String sql){...}
function boolean containsSuspectString(String sql){...}</pre>
                    </div>
                </div>
                <h3 class="auto-cursor-target" id="RuleStagesandObjects-UniqueFunctionSignatureExamples">Unique Function Signature Examples</h3>
                <div class="code panel pdl conf-macro output-block" style="border-width: 1px;">
                    <div class="codeContent panelContent pdl"><pre class="syntaxhighlighter-pre" xml:space="preserve"># Unique Return Types
function boolean containsSuspectString(String sql){...}
function char containsSuspectString(String sql){...}

# Unique Names
function boolean containsSuspectString(String sql){...}
function boolean hasSuspectString(String sql){...}

# Unique Arguments
function boolean containsSuspectString(String sql){...}
function boolean containsSuspectString(Char[] sql){...}

</pre>
                    </div>
                </div>
                <h3 class="auto-cursor-target" id="RuleStagesandObjects-UsingSharedFunctionsAcrossMultipleRules">Using Shared Functions Across Multiple Rules</h3>
                <p class="auto-cursor-target">If you want to use the same functions in multiple rule files in a package, you can include the functions in a single file and import them as needed into your rules.</p>
                <p class="auto-cursor-target">Suggested method to package utility functions:&#160;</p>
                <p><code>package <strong><em>&lt;company&gt;.rules.utilities</em></strong></code>
                </p>
                <p>
                    <br />
                </p>
            </div>
        </div>
        <h1 id="RuleStagesandObjects-_Toc485899183RuleResponses"><span class="confluence-anchor-link conf-macro output-inline" id="RuleStagesandObjects-_Toc485899183"></span>Rule Responses</h1>
        <p>Rules contain the ability to assess how the rule affects the deployment process and communicate the impact.</p>
        <p>You can specify the information that gets passed back to the calling application. The information passed back is in the form of a Response object that has three parts:</p>
        <ul>
            <li>Name of the rule that created the response</li>
            <li>ResponseType that indicates whether the response should cause the forecast to stop or not</li>
            <li>Message containing details about what the rule has detected.</li>
        </ul>
        <p>When the deployment process is run manually through Deploy Packager, you can read the responses in the output from the deployment.&#160;</p>
        <p>When the deployment process is automated, the calling program will examine all the responses from all the rules and can react accordingly. It can let the deployment start or flag the step as having a problem that needs further investigation. The calling program is typically part of automation software, such as Jenkins, IBM Urban Code Deploy, or CA Deployment Automation.&#160;</p>
        <p><strong>Valid Response Types</strong>
        </p>
        <ul>
            <li>ResponseType.PASS</li>
            <li>ResponseType.WARN</li>
            <li>ResponseType.FAIL</li>
        </ul>
        <p><strong>Usage</strong>
        </p>
        <p><code>insert(new Response(responseType, errorMessage, ruleName));</code>
        </p>
        <p><strong>Example</strong>
        </p>
        <p><code>insert(new Response(ResponseType.WARN, "Today is March 15<sup>,</sup> beware the ides of March!", "Ides of March Rule"));</code>
        </p>
    </body>
</html>