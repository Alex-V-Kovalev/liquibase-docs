<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head><title>Best Practices for Multiple Teams Deploying to the Same Instance (SQL Server)</title>
        <meta rel="canonical" href="https://docs.liquibase.com/concepts/bestpractices.html" />
        <meta name="description" content="This document discusses use cases when there are multiple teams that deploy to the same database instance." />
    </head>
    <body>
        <h1>Best Practices for Multiple Teams Deploying to the Same Instance (SQL Server)</h1>
        <p>This document discusses use cases when there are multiple teams that deploy to the same database instance. We will discuss the following two use cases in this scenario:</p>
        <ol>
            <li>Each team has one or more dedicated database(s) in the same database instance</li>
            <li>Multiple teams write to one or more shared databases in the same database instance</li>
        </ol>
        <h2>Use case 1: Each team has one or more dedicated database in the same instance</h2>
        <p>This is a common use case for applications that integrate multiple subsystems. Multiple teams, each with their own Git repository, deploy database changes into their own dedicated databases in the same database instance. </p>
        <table>
            <col />
            <col />
            <col />
            <tbody>
                <tr>
                    <th>Team</th>
                    <th>Service account</th>
                    <th>Database</th>
                </tr>
                <tr>
                    <td>Team 1</td>
                    <td>svc_team1_dbA</td>
                    <td>DatabaseA</td>
                </tr>
                <tr>
                    <td>Team 2</td>
                    <td>svc_team2_dbB</td>
                    <td>DatabaseB</td>
                </tr>
                <tr>
                    <td>Team 3</td>
                    <td>svc_team3_dbC</td>
                    <td>DatabaseC</td>
                </tr>
                <tr>
                    <td>Team4</td>
                    <td>svc_team4_dbD</td>
                    <td>DatabaseD</td>
                </tr>
            </tbody>
        </table>
        <h3>Structuring Git repository</h3>
        <p>Each team will dedicate a directory in their repository for database changes. In this directory, they can manage all their scripts along with the changelog.xml file. The team can also create a directory for their database.</p>
        <img src="../Z_Resources/Images/best-practices/multi-team-sqlserver1.png" />
        <p>In the case of a team deploying to multiple database, they could organize their repository where they have a subdirectory for each database.</p>
        <img src="../Z_Resources/Images/best-practices/multi-team-sqlserver2.png" />
        <p>The team needs a master changelog file which can control the flow of all changes to all database.</p>
        <p>See the section “Deploying with Liquibase” later in this document for sample scripts.</p>
        <h2>Use case 2: Multiple teams write to one or more shared database in the same instance</h2>
        <p>In this use case, multiple teams, each with their own Git repository, deploy database changes to one or more shared databases. This use case is common for legacy applications that have added subsystems over time or other complex application architectures.</p>
        <table>
            <col />
            <col />
            <tbody>
                <tr>
                    <th>Team</th>
                    <th>Databases</th>
                </tr>
                <tr>
                    <td>Team 1</td>
                    <td rowspan="4">
                        <p rowspan="4">DatabaseA, DatabaseB, DatabaseC</p>
                    </td>
                </tr>
                <tr>
                    <td>Team 2</td>
                </tr>
                <tr>
                    <td>Team 3</td>
                </tr>
                <tr>
                    <td>Team4</td>
                </tr>
            </tbody>
        </table>
        <p>There are three important considerations here:</p>
        <ol>
            <li>You will use a single URL and credentials to connect to all databases. This requires that you use a single service account which has permissions to multiple databases.</li>
            <li>Within SQL scripts, each object would need to be fully qualified with database name, schema name and object name. This is a requirements because of the single service account used to deploy to multiple databases.</li>
            <li>Liquibase tracking tables (<code>DATABASECHANGELOG</code> and <code>DATABASECHANGELOGLOCK</code>) will be created only in one database that is specified in the URL. Deployments to multiple databases will be tracked by a single <code>DATABASECHANGELOG</code> tracking table in the database specified in the URL.</li>
        </ol>
        <p class="note" MadCap:autonum="&lt;b&gt;Note: &lt;/b&gt;">It is important to understand that teams must communicate with each other about their database changes going into shared databases. Database changes often have dependencies, and these changes need to be coordinated so that they are deployed in the correct order.</p>
        <h3>Structuring Git repository</h3>
        <p>When multiple teams share common schemas, it is not possible to use each team’s own application repository. This use case requires setting up a dedicated SQL repository for shared databases.</p>
        <img src="../Z_Resources/Images/best-practices/multi-team-sqlserver3.png" />
        <p>The team needs a master changelog file that can control the flow of all changes to all databases.</p>
        <p>See the section “Deploying with Liquibase” later in this document for sample scripts.</p>
        <h2>Sample masterChangelog.xml</h2>
        <p>Here is a sample masterChangelog.xml file which can be used in a multi-database repository:</p>
        <MadCap:codeSnippet>
            <MadCap:codeSnippetCopyButton />
            <MadCap:codeSnippetBody MadCap:useLineNumbers="True" MadCap:lineNumberStart="1" MadCap:continue="False" xml:space="preserve" style="mc-code-lang: XML;">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;databaseChangeLog
       xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:pro="http://www.liquibase.org/xml/ns/pro"
       xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd
   http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-4.6.xsd "&gt;

&lt;include file="databaseA/changeLog.xml"/&gt;
&lt;include file="databaseB/changeLog.xml"/&gt;
&lt;include file="databaseC/changeLog.xml"/&gt;

&lt;/databaseChangeLog&gt;</MadCap:codeSnippetBody>
        </MadCap:codeSnippet>
        
        <h2>Deploying with Liquibase</h2>
        <p>The basic script for deploying with Liquibase using a single service account to deploy to multiple shared databases looks like this:</p>
        <MadCap:codeSnippet>
            <MadCap:codeSnippetCopyButton />
            <MadCap:codeSnippetBody MadCap:useLineNumbers="True" MadCap:lineNumberStart="1" MadCap:continue="False" xml:space="preserve" style="mc-code-lang: PowerShell;"># add liquibase path to the environment variable
export PATH=&lt;Path to Liquibase&gt;:${PATH}

# git clone or retrieve a versioned artifact
git clone &lt;GIT URL to the repo&gt; 

cd &lt;Repo&gt;/sql_code

# run the “status” command
liquibase --changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          status -–verbose

# run the “update” command
liquibase --changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          update

# run the “history” command
liquibase --changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          history
</MadCap:codeSnippetBody>
        </MadCap:codeSnippet>
        
        <p>The script for deploying with Liquibase using proxy users to deploy to one database at a time looks like this. This is for the SQL Server use case (not the use of <code>--default-catalog-name argument</code>):</p>
        <MadCap:codeSnippet>
            <MadCap:codeSnippetCopyButton />
            <MadCap:codeSnippetBody MadCap:useLineNumbers="True" MadCap:lineNumberStart="1" MadCap:continue="False" xml:space="preserve" style="mc-code-lang: PowerShell;"># add liquibase path to the environment variable
export PATH=&lt;Path to Liquibase&gt;:${PATH}

# git clone or retrieve a versioned artifact
git clone &lt;GIT URL to the repo&gt; 

cd &lt;Repo&gt;/sql_code

LBDATABASENAMES="${1:-"HR OC OE SH"}"

for LBDATABASE in $ LBDATABASENAMES
do

# run the “status” command
liquibase --changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          --default-catalog-name=${LBDATABASE} \
          status –-verbose

# run the “update” command
liquibase –-changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          --default-catalog-name=${LBDATABASE} \
          update

# run the “history” command
liquibase --changelog-file=masterChangelog.xml \
          --url=&lt;Database URL&gt; \
          --username=&lt;username&gt; \
          --password=&lt;password&gt; \
          --default-catalog-name=${LBDATABASE} \
          history</MadCap:codeSnippetBody>
        </MadCap:codeSnippet>
        <p>Liquibase automatically creates DATABASECHANGELOG and DATABASECHANGELOGLOCK tables (also called DBCL tables) for tracking deployments. These tables are created in the default database for the user connecting to the instance.
</p>
        <p>If you want your DBCL tables to be created in another database, e.g., a dedicated database for Liquibase tracking only, then you can use the --<code>liquibase-catalog-name=&lt;database&gt;</code> to indicate your specific database. You will need to make sure that the service account allows creating DBCL tables in this database, as well as querying these tables.
</p>
        <ul>
            <li><code>--liquibase-schema-name=&lt;database&gt;</code>
                <ul>
                    <li>The parameter specifies the database to use for the creation of Liquibase objects, like the DATABASECHANGELOG and DATABASECHANGELOGLOCK tracking tables.</li>
                </ul>
            </li>
            <li><code>--default-schema-name=&lt;database&gt;</code>
                <ul>
                    <li>The parameter specifies the default database name to use for the database connection.</li>
                </ul>
            </li>
        </ul>
    </body>
</html>