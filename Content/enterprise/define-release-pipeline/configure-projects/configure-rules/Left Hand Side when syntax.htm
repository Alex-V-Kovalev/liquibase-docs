<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" xml:lang="en-us">
	<head>
		<title>Liquibase Enterprise Documentation</title>
	</head>
	<body>
		<h1>Left Hand Side (when) syntax</h1>
		<MadCap:snippetText src="../../../../Resources/Snippets/images/.ver_icon_size_enterprise.flsnp" />
		<p>The Left Hand Side (LHS) is a common name for the conditional part of the rule. It consists of zero or more Conditional Elements. If the LHS is empty, it will be considered as a condition element that is always true and it will be activated once, when a new WorkingMemory session is created.</p>
		<p><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax.png" /></p>
		<p>The following is an example of a rule without a conditional element.</p>
		<p class="HTMLPreformatted">rule "no CEs"</p>
		<p class="HTMLPreformatted">when</p>
		<p class="HTMLPreformatted">&#160; // empty</p>
		<p class="HTMLPreformatted">then</p>
		<p class="HTMLPreformatted">&#160; ... // actions (executed once)</p>
		<p class="HTMLPreformatted">end</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">// The above rule is internally rewritten as:</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">rule "no CEs"</p>
		<p class="HTMLPreformatted">when</p>
		<p class="HTMLPreformatted">&#160; eval( true )</p>
		<p class="HTMLPreformatted">then</p>
		<p class="HTMLPreformatted">&#160; ... // actions (executed once)</p>
		<p class="HTMLPreformatted">end</p>
		<p>Conditional elements work on one or more patterns (which are described below). The most common conditional element is "and". Therefore it is implicit when you have multiple patterns in the LHS of a rule that are not connected in any way:</p>
		<p class="HTMLPreformatted">rule "2 unconnected patterns"</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">when</p>
		<p class="HTMLPreformatted">&#160; Pattern1()</p>
		<p class="HTMLPreformatted">&#160; Pattern2()</p>
		<p class="HTMLPreformatted">then</p>
		<p class="HTMLPreformatted"> ... // actions</p>
		<p class="HTMLPreformatted">end</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">// The above rule is internally rewritten as:</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">rule "2 AND connected patterns" when</p>
		<p class="HTMLPreformatted">&#160; Pattern1()</p>
		<p class="HTMLPreformatted">&#160; and Pattern2()</p>
		<p class="HTMLPreformatted">then</p>
		<p class="HTMLPreformatted">&#160; ... // actions</p>
		<p class="HTMLPreformatted">end</p>
		<p><span class="Strong">Note</span><br />An "and" cannot have a leading declaration binding (unlike, for example, or). This is obvious, since a declaration can only reference a single fact at a time, and when the "and" is satisfied it matches both facts - so which fact would the declaration bind to?</p>
		<p class="HTMLPreformatted">// Compile error</p>
		<p class="HTMLPreformatted">$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))</p>
		<h2>Pattern (conditional element)</h2>
		<p>A pattern element is the most important Conditional Element. It can potentially match on each fact that is inserted in the working memory.</p>
		<p>A pattern contains of zero or more constraints and has an optional pattern binding. The railroad diagram below shows the syntax for this.</p>
		<p><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax_1.png" /></p>
		<p>In its simplest form, with no constraints, a pattern matches against a fact of the given type. In the following case the type is Cheese, which means that the pattern will match against all Person objects in the Working Memory:</p>
		<p class="HTMLPreformatted">Person()</p>
		<p>The type need not be the actual class of some fact object. Patterns may refer to superclasses or even interfaces, thereby potentially matching facts from many different classes.</p>
		<p class="HTMLPreformatted">Object() // matches all objects in the working memory</p>
		<p>Inside of the pattern parenthesis is where all the action happens: it defines the constraints for that pattern. For example, with a age related constraint:</p>
		<p class="HTMLPreformatted">Person( age == 100 )</p>
		<p><span class="Strong">Note</span><br />For backwards compatibility reasons it's allowed to suffix patterns with the ";" character. But it is not recommended to do that.</p>
		<h2>Pattern binding</h2>
		<p>For referring to the matched object, use a pattern binding variable such as $p.</p>
		<p>Pattern with a binding variable</p>
		<p class="HTMLPreformatted">rule ...</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">when</p>
		<p class="HTMLPreformatted">&#160; $p : Person()</p>
		<p class="HTMLPreformatted">then</p>
		<p class="HTMLPreformatted">&#160; System.out.println( "Person " + $p );</p>
		<p class="HTMLPreformatted">end</p>
		<p>The prefixed dollar symbol ($) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields, but it is not mandatory.</p>
		<h2>Constraint (part of a pattern)</h2>
		<p>A constraint is an expression that returns true or false. This example has a constraint that states 5 is smaller than 6:</p>
		<p class="HTMLPreformatted">Person( 5 &lt; 6 ) // just an example - constraints like this would be useless in a real pattern</p>
		<p>In essence, it's a Java expression with some enhancements (such as property access) and a few differences (such as equals() semantics for ==). Let's take a deeper look.</p>
		<h2>Property access on Java Beans (POJO's)</h2>
		<p>Any bean property can be used directly. A bean property is exposed using a standard Java bean getter: a method getMyProperty() (or isMyProperty() for a primitive boolean) which takes no arguments and return something. For example: the age property is written as age in DRL instead of the getter getAge():</p>
		<p class="HTMLPreformatted">Person( age == 50 )</p>
		<p class="HTMLPreformatted">// this is the same as:</p>
		<p class="HTMLPreformatted">Person( getAge() == 50 )</p>
		<p>Drools uses the standard JDK Introspector class to do this mapping, so it follows the standard Java bean specification.</p>
		<p>Use property access (age) over using getters explicitly (getAge()) because of performance enhancements through field indexing.</p>
		<p>Property accessors must not change the state of the object in a way that may affect the rules. Remember that the rule engine effectively caches the results of its matching in between invocations to make it faster.</p>
		<p class="HTMLPreformatted">public int getAge() {</p>
		<p class="HTMLPreformatted">&#160; age++; // Do NOT do this</p>
		<p class="HTMLPreformatted">&#160; return age;</p>
		<p class="HTMLPreformatted">}</p>
		<p>Nested property access is supported:</p>
		<p class="HTMLPreformatted">Person( address.houseNumber == 50 )</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">// this is the same as:</p>
		<p class="HTMLPreformatted">&#160;</p>
		<p class="HTMLPreformatted">Person( getAddress().getHouseNumber() == 50 )</p>
		<h2>Java expression</h2>
		<p>You can use any Java expression that returns a boolean as a constraint inside the parentheses of a pattern. Java expressions can be mixed with other expression enhancements, such as property access:</p>
		<p class="HTMLPreformatted">Person( age == 50 )</p>
		<p>It is possible to change the evaluation priority by using parentheses, as in any logic or mathematical expression:</p>
		<p class="HTMLPreformatted">Person( age &gt; 100 &amp;&amp; ( age % 10 == 0 ) )</p>
		<p>It is possible to reuse Java methods:</p>
		<p class="HTMLPreformatted">Person( Math.round( weight / ( height * height ) ) &lt; 25.0 )</p>
		<p><span class="Strong">Warnings</span></p>
		<p>As for property accessors, methods must not change the state of the object in a way that may affect the rules. Any method executed on a fact in the LHS should be a read only method.</p>
		<p class="HTMLPreformatted">Person( incrementAndGetAge() == 10 ) // Do NOT do this</p>
		<p>The state of a fact should not change between rule invocations (unless those facts are marked as updated to the working memory on every change):</p>
		<p class="HTMLPreformatted">Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this</p>
		<p>Normal Java operator precedence applies; see the operator precedence list below.</p>
		<p><span class="Strong">Important</span><br />All operators have normal Java semantics except for == and !=. The == operator has null-safe equals() semantics:</p>
		<p class="HTMLPreformatted">// Similar to: java.util.Objects.equals(person.getFirstName(), "John")</p>
		<p class="HTMLPreformatted">// so (because "John" is not null) similar to:</p>
		<p class="HTMLPreformatted">// "John".equals(person.getFirstName())</p>
		<p class="HTMLPreformatted">Person( firstName == "John" )</p>
		<p>The != operator has null-safe !equals() semantics:</p>
		<p class="HTMLPreformatted">// Similar to: !java.util.Objects.equals(person.getFirstName(), "John")</p>
		<p class="HTMLPreformatted">Person( firstName != "John" )</p>
		<p>Type coercion is always attempted if the field and the value are of different types; exceptions will be thrown if a bad coercion is attempted. For instance, if "ten" is provided as a string in a numeric evaluator, an exception is thrown, whereas "10" would coerce to a numeric 10. Coercion is always in favor of the field type and not the value type:</p>
		<p class="HTMLPreformatted">Person( age == "10" ) // "10" is coerced to 10</p>
		<h2>Comma separated AND</h2>
		<p>The comma character (',') is used to separate constraint groups. It has implicit AND connective semantics.</p>
		<p class="HTMLPreformatted">// Person is at least 50 and weighs at least 80 kg</p>
		<p class="HTMLPreformatted">Person( age &gt; 50, weight &gt; 80 )</p>
		<p class="HTMLPreformatted">// Person is at least 50, weighs at least 80 kg and is taller than 2 meter.</p>
		<p class="HTMLPreformatted">Person( age &gt; 50, weight &gt; 80, height &gt; 2 )</p>
		<p><span class="Strong">Note</span></p>
		<p>Although the &amp;&amp; and , operators have the same semantics, they are resolved with different priorities: The &amp;&amp; operator precedes the || operator. Both the &amp;&amp; and || operator precede the , operator. See the operator precedence list below.</p>
		<p>The comma operator should be preferred at the top level constraint, as it makes constraints easier to read and the engine will often be able to optimize them better.</p>
		<p>The comma (,) operator cannot be embedded in a composite constraint expression, such as parentheses:</p>
		<p class="HTMLPreformatted">Person( ( age &gt; 50, weight &gt; 80 ) || height &gt; 2 ) // Do NOT do this: compile error</p>
		<p class="HTMLPreformatted">// Use this instead</p>
		<p class="HTMLPreformatted">Person( ( age &gt; 50 &amp;&amp; weight &gt; 80 ) || height &gt; 2 )</p>
		<h2>Binding variables</h2>
		<p>A property can be bound to a variable:</p>
		<p class="HTMLPreformatted">// 2 persons of the same age</p>
		<p class="HTMLPreformatted">Person( $firstAge : age ) // binding</p>
		<p class="HTMLPreformatted">Person( age == $firstAge ) // constraint expression</p>
		<p>The prefixed dollar symbol ($) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields.</p>
		<p><span class="Strong">Note</span></p>
		<p>For backwards compatibility reasons, it's allowed (but not recommended) to mix a constraint binding and constraint expressions as such:</p>
		<p class="HTMLPreformatted">// Not recommended</p>
		<p class="HTMLPreformatted">Person( $age : age * 2 &lt; 100 )</p>
		<p class="HTMLPreformatted">// Recommended (separates bindings and constraint expressions)</p>
		<p class="HTMLPreformatted">Person( age * 2 &lt; 100, $age : age )</p>
		<p>Bound variable restrictions using the operator == provide for very fast execution as it use hash indexing to improve performance.</p>
		<h2>Unification</h2>
		<p>Drools does not allow bindings to the same declaration. However this is an important aspect to derivation query unification. While positional arguments are always processed with unification a special unification symbol, ':=', was introduced for named arguments named arguments. The following "unifies" the age argument across two people.</p>
		<p class="HTMLPreformatted">Person( $age := age )</p>
		<p class="HTMLPreformatted">Person( $age := age)</p>
		<p>In essence unification will declare a binding for the first occurrence and constrain to the same value of the bound field for sequence occurrences.</p>
		<h2>Grouped accessors for nested objects</h2>
		<p>Often it happens that it is necessary to access multiple properties of a nested object as in the following example</p>
		<p class="HTMLPreformatted">Person( name == "mark", address.city == "london", address.country == "uk" )</p>
		<p>These accessors to nested objects can be grouped with a '.(...)' syntax providing more readable rules as in</p>
		<p class="HTMLPreformatted">Person( name == "mark", address.( city == "london", country =="uk") )</p>
		<p>Note the '.' prefix, this is necessary to differentiate the nested object constraints from a method call.</p>
		<h2>Inline casts and coercion</h2>
		<p>When dealing with nested objects, it also quite common the need to cast to a subtype. It is possible to do that via the # symbol as in:</p>
		<p class="HTMLPreformatted">Person( name=="mark", address#LongAddress.country == "uk" )</p>
		<p>This example casts Address to LongAddress, making its getters available. If the cast is not possible (instanceof returns false), the evaluation will be considered false. Also fully qualified names are supported:</p>
		<p class="HTMLPreformatted">Person( name=="mark", address#org.domain.LongAddress.country == "uk" )</p>
		<p>It is possible to use multiple inline casts in the same expression:</p>
		<p class="HTMLPreformatted">Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</p>
		<p>Moreover, since we also support the instanceof operator, if that is used we will infer its results for further uses of that field, within that pattern:</p>
		<p class="HTMLPreformatted">Person( name=="mark", address instanceof LongAddress, address.country == "uk" )</p>
		<h2>Special literal support</h2>
		<p>Besides normal Java literals (including Java 5 enums), this literal is also supported:</p>
		<h2>Date literal</h2>
		<p>The date format <span class="HTMLCode_1">dd-mmm-yyyy</span> is supported by default. You can customize this by providing an alternative date format mask as the System property named <span class="HTMLCode_1">drools.dateformat</span>. If more control is required, use a restriction.</p>
		<p class="HTMLPreformatted">Cheese( bestBefore &lt; "27-Oct-2009" )</p>
		<h2>List and Map access</h2>
		<p>It's possible to directly access a List value by index:</p>
		<p class="HTMLPreformatted">// Same as childList(0).getAge() == 18</p>
		<p class="HTMLPreformatted">Person( childList[0].age == 18 )</p>
		<p>It's also possible to directly access a Map value by key:</p>
		<p class="HTMLPreformatted">// Same as credentialMap.get("jsmith").isValid()</p>
		<p class="HTMLPreformatted">Person( credentialMap["jsmith"].valid )</p>
		<h2>Abbreviated combined relation condition</h2>
		<p>This allows you to place more than one restriction on a field using the restriction connectives &amp;&amp; or ||. Grouping via parentheses is permitted, resulting in a recursive syntax pattern. <br />Abbreviated combined relation condition</p>
		<p><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax_2.png" /></p>
		<p>Abbreviated combined relation condition with parentheses</p>
		<p><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax_3.png" /></p>
		<p class="HTMLPreformatted">// Simple abbreviated combined relation condition using a single &amp;&amp;</p>
		<p class="HTMLPreformatted">Person( age &gt; 30 &amp;&amp; &lt; 40 )</p>
		<p class="HTMLPreformatted">// Complex abbreviated combined relation using groupings</p>
		<p class="HTMLPreformatted">Person( age((&gt; 30 &amp;&amp; &lt; 40) ||</p>
		<p class="HTMLPreformatted">(&gt; 20 &amp;&amp; &lt; 25) ) )</p>
		<p class="HTMLPreformatted">// Mixing abbreviated combined relation with constraint connectives</p>
		<p class="HTMLPreformatted">Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</p>
		<h2>Special DRL operators</h2>
		<h2><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax_4.png" /></h2>
		<p>Coercion to the correct value for the evaluator and the field will be attempted.</p>
		<h2>The operators &lt; &lt;= &gt; &gt;=</h2>
		<p>These operators can be used on properties with natural ordering. For example, for Date fields, &lt; means before, for String fields, it means alphabetically lower.</p>
		<p class="HTMLPreformatted">Person( firstName &lt; $otherFirstName )</p>
		<p class="HTMLPreformatted">Person( birthDate &lt; $otherBirthDate )</p>
		<p>Only applies on Comparable properties.</p>
		<h2>Null-safe dereferencing operator</h2>
		<p>The !. operator allows derefencing in a null-safe way. More in details the matching algorithm requires the value to the left of the !. operator to be not null in order to give a positive result for pattern matching itself. In other words the pattern:</p>
		<p class="HTMLPreformatted">Person( $streetName : address!.street )</p>
		<p>will be internally translated in:</p>
		<p class="HTMLPreformatted">Person( address != null, $streetName : address.street )</p>
		<h2>The operator matches</h2>
		<p>Matches a field against any valid Java Regular Expression. Typically that regexp is a string literal, but variables that resolve to a valid regexp are also allowed.</p>
		<p class="HTMLPreformatted">Cheese( type matches "(Buffalo)?\\S*Mozarella" )</p>
		<p>Note: Like in Java, regular expressions written as string literals need to escape '\'.</p>
		<p>Only applies on String properties. Using matches against a null value always evaluates to false.</p>
		<h2>The operator not matches</h2>
		<p>The operator returns true if the String does not match the regular expression. The same rules apply as for the matches operator.</p>
		<p>Example:</p>
		<p class="HTMLPreformatted">Cheese( type not matches "(Buffulo)?\\S*Mozarella" )</p>
		<p>Only applies on String properties. Using not matches against a null value always evaluates to true.</p>
		<h2>The operator contains</h2>
		<p>The operator contains is used to check whether a field that is a Collection or elements contains the specified value.</p>
		<p class="HTMLPreformatted">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal</p>
		<p class="HTMLPreformatted">CheeseCounter( cheeses contains $var ) // contains with a variable</p>
		<p>Only applies on Collection properties.</p>
		<h2>The operator not contains</h2>
		<p>The operator not contains is used to check whether a field that is a Collection or elements does not contain the specified value.</p>
		<p class="HTMLPreformatted">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal</p>
		<p></p>
		<p class="HTMLPreformatted">CheeseCounter( cheeses not contains $var ) // not contains with a variable</p>
		<p>Only applies on Collection properties.</p>
		<p><span class="Strong">Note</span></p>
		<p>For backward compatibility, the excludes operator is supported as a synonym for not contains.</p>
		<h2>The operator memberOf</h2>
		<p>The operator memberOf is used to check whether a field is a member of a collection or elements; that collection must be a variable.</p>
		<p class="HTMLPreformatted">CheeseCounter( cheese memberOf $matureCheeses )</p>
		<h2>The operator not memberOf</h2>
		<p>The operator not memberOf is used to check whether a field is not a member of a collection or elements; that collection must be a variable.</p>
		<p class="HTMLPreformatted">CheeseCounter( cheese not memberOf $matureCheeses )</p>
		<h2>The operator soundslike</h2>
		<p>This operator is similar to matches, but it checks whether a word has almost the same sound (using English pronunciation) as the given value. This is based on the Soundex algorithm (see <a href="http://en.wikipedia.org/wiki/Soundex">http://en.wikipedia.org/wiki/Soundex</a>).</p>
		<p class="HTMLPreformatted">// match cheese "fubar" or "foobar"</p>
		<p class="HTMLPreformatted">Cheese( name soundslike 'foobar' )</p>
		<h2>The operator str</h2>
		<p>This operator str is used to check whether a field that is a String starts with or ends with a certain value. It can also be used to check the length of the String.</p>
		<p class="HTMLPreformatted">Message( routingValue str[startsWith] "R1" )</p>
		<p class="HTMLPreformatted">Message( routingValue str[endsWith] "R2" )</p>
		<p class="HTMLPreformatted">Message( routingValue str[length] 17 )</p>
		<h2>The operators in and not in (compound value restriction)</h2>
		<p>The compound value restriction is used where there is more than one possible value to match. Currently only the in and not in evaluators support this. The second operand of this operator must be a comma-separated list of values, enclosed in parentheses. Values may be given as variables, literals, return values or qualified identifiers. Both evaluators are actually syntactic sugar, internally rewritten as a list of multiple restrictions using the operators != and ==. <br /><img src="../../../../Resources/Images/Rule+Syntax+and+Construction/Left Hand Side when syntax_5.png" /></p>
		<p class="HTMLPreformatted">Person( $cheese : favouriteCheese )</p>
		<p class="HTMLPreformatted">Cheese( type in ( "stilton", "cheddar", $cheese ) )</p>
		<h2>Operator precedence</h2>
		<table>
			<col class="col_1" />
			<col class="col_2" />
			<col class="col_3" />
			<tbody>
				<tr>
					<td>
						<p>Operator type</p>
					</td>
					<td>
						<p>Operators</p>
					</td>
					<td>
						<p>Notes</p>
					</td>
				</tr>
				<tr>
					<td>
						<p>(nested / null safe) property access</p>
					</td>
					<td>
						<p><span class="span_1">.</span> <span class="span_1">!.</span></p>
					</td>
					<td>
						<p>Not normal Java semantics</p>
					</td>
				</tr>
				<tr>
					<td>
						<p>List/Map access</p>
					</td>
					<td>
						<p>[ ]</p>
					</td>
					<td>
						<p>Not normal Java semantics</p>
					</td>
				</tr>
				<tr>
					<td>
						<p>constraint binding</p>
					</td>
					<td>
						<p>:</p>
					</td>
					<td>
						<p>Not normal Java semantics</p>
					</td>
				</tr>
				<tr>
					<td>
						<p>multiplicative</p>
					</td>
					<td>
						<p><span class="span_1">*</span> <span class="span_1">/</span> <span class="span_1">%</span></p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>additive</p>
					</td>
					<td>
						<p><span class="span_1">+</span> <span class="span_1">-</span></p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>shift</p>
					</td>
					<td>
						<p><span class="span_1">&lt;&lt;</span> <span class="span_1">&gt;&gt;</span> <span class="span_1">&gt;&gt;&gt;</span></p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>relational</p>
					</td>
					<td>
						<p><span class="span_1">&lt;</span> <span class="span_1">&gt;</span> <span class="span_1">&lt;=</span> <span class="span_1">&gt;=</span> <span class="span_1">instanceof</span></p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>equality</p>
					</td>
					<td>
						<p><span class="span_1">==</span> <span class="span_1">!=</span></p>
					</td>
					<td>
						<p>Does not use normal Java (not) same semantics: uses (not) equals semantics instead.</p>
					</td>
				</tr>
				<tr>
					<td>
						<p>non-short circuiting AND</p>
					</td>
					<td>
						<p>&amp;</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>non-short circuiting exclusive OR</p>
					</td>
					<td>
						<p>^</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>non-short circuiting inclusive OR</p>
					</td>
					<td>
						<p>|</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>logical AND</p>
					</td>
					<td>
						<p>&amp;&amp;</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>logical OR</p>
					</td>
					<td>
						<p>||</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>ternary</p>
					</td>
					<td>
						<p>? :</p>
					</td>
					<td>
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
						<p>Comma separated AND</p>
					</td>
					<td>
						<p>,</p>
					</td>
					<td>
						<p>Not normal Java semantics</p>
					</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>