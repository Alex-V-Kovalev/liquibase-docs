<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" xml:lang="en-us">
    <head><title></title>
        <link href="../../../../../Resources/Stylesheets/Data+Models+for+Rules.css" rel="stylesheet" />
    </head>
    <body>
        <h1 class="Heading1">Basic conditional elements</h1> <MadCap:snippetText src="../../../../../Resources/Snippets/images/.ver_icon_size_enterprise.flsnp" /><h2 class="Heading2">Conditional Element and</h2><p>The Conditional Element "and" is used to group other Conditional Elements into a logical conjunction. Drools supports both prefix and and infix and.</p><h3 class="Heading3">Infix and</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements.png" class="img_11" /></p><p>Traditional infix and is supported:</p><p class="HTMLPreformatted">//infixAnd</p><p class="HTMLPreformatted">Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType ) </p><p>Explicit grouping with parentheses is also supported:</p><p class="HTMLPreformatted">//infixAnd with grouping</p><p class="HTMLPreformatted">( Cheese( cheeseType : type ) and</p><p class="HTMLPreformatted">( Person( favouriteCheese == cheeseType ) or</p><p class="HTMLPreformatted">Person( favouriteCheese == cheeseType ) ) </p><p><span class="Strong">Note</span></p><p>The symbol &amp;&amp; (as an alternative to and) is deprecated. But it is still supported in the syntax for backwards compatibility.</p><h3 class="Heading3">Prefix and</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_1.png" class="img_12" /></p><p>Prefix and is also supported:</p><h2 class="Heading2">Conditional Element or</h2><p>The Conditional Element or is used to group other Conditional Elements into a logical disjunction. Drools supports both prefix or and infix or.</p><h3 class="Heading3">Infix or</h3><p>&#160;</p><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_2.png" class="img_13" /><br />Traditional infix or is supported:</p><p class="HTMLPreformatted">//infixOr</p><p class="HTMLPreformatted">Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType ) </p><p>Explicit grouping with parentheses is also supported:</p><p class="HTMLPreformatted">//infixOr with grouping</p><p class="HTMLPreformatted">&#160;&#160; ( Cheese( cheeseType : type ) or</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; ( Person( favouriteCheese == cheeseType ) and</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Person( favouriteCheese == cheeseType ) ) </p><p><span class="Strong">Note</span><br />The symbol || (as an alternative to or) is deprecated. But it is still supported in the syntax for backwards compatibility.</p><h3 class="Heading3">Prefix or</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_3.png" class="img_14" /></p><p>Prefix or is also supported:</p><p class="HTMLPreformatted">(or Person( sex == "f", age &gt; 60 )</p><p class="HTMLPreformatted">Person( sex == "m", age &gt; 65 ) </p><p><span class="Strong">Note</span></p><p>The behavior of the Conditional Element or is different from the connective || for constraints and restrictions in field constraints. The engine actually has no understanding of the Conditional Element or. Instead, via a number of different logic transformations, a rule with or is rewritten as a number of subrules. This process ultimately results in a rule that has a single or as the root node and one subrule for each of its CEs. Each subrule can activate and fire like any normal rule; there is no special behavior or interaction between these subrules. - This can be most confusing to new rule authors.</p><p>The Conditional Element or also allows for optional pattern binding. This means that each resulting subrule will bind its pattern to the pattern binding. Each pattern must be bound separately, using eponymous variables:</p><p class="HTMLPreformatted">pensioner : (Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 )) </p><p>&#160;</p><p class="HTMLPreformatted">(or pensioner : Person( sex == "f", age &gt; 60 )</p><p class="HTMLPreformatted">pensioner : Person( sex == "m", age &gt; 65 ) ) </p><p>Since the conditional element or results in multiple subrule generation, one for each possible logically outcome, the example above would result in the internal generation of two rules. These two rules work independently within the Working Memory, which means both can match, activate and fire - there is no shortcutting.</p><p>The best way to think of the conditional element or is as a shortcut for generating two or more similar rules. When you think of it that way, it's clear that for a single rule there could be multiple activations if two or more terms of the disjunction are true.</p><h2 class="Heading2">Conditional Element not</h2><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_4.png" class="img_15" /></p><p>The CE not is first order logic's non-existential quantifier and checks for the non-existence of something in the Working Memory. Think of "not" as meaning "there must be none of...".</p><p>The keyword not may be followed by parentheses around the CEs that it applies to. In the simplest case of a single pattern (like below) you may optionally omit the parentheses.</p><p><span class="Strong">No Buses</span></p><p class="HTMLPreformatted">not Bus() </p><p><span class="Strong">No Red Buses</span></p><p class="HTMLPreformatted">// Brackets are optional:</p><p class="HTMLPreformatted">not Bus(color == "red") </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">// Brackets are optional:</p><p class="HTMLPreformatted">not ( Bus(color == "red", number == 42) ) </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">// "not" with nested infix and - two patterns,</p><p class="HTMLPreformatted">// brackets are required:</p><p class="HTMLPreformatted">not ( Bus(color == "red") and</p><p class="HTMLPreformatted">Bus(color == "blue") ) </p><h2 class="Heading2">Conditional Element exists</h2><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_5.png" class="img_15" /></p><p>The CE exists is first order logic's existential quantifier and checks for the existence of something in the Working Memory. Think of "exists" as meaning "there is at least one..". It is different from just having the pattern on its own, which is more like saying "for each one of...". If you use exists with a pattern, the rule will only activate at most once, regardless of how much data there is in working memory that matches the condition inside of the exists pattern. Since only the existence matters, no bindings will be established.</p><p>The keyword exists must be followed by parentheses around the CEs that it applies to. In the simplest case of a single pattern (like below) you may omit the parentheses.</p><p><span class="Strong">At least one Bus</span></p><p class="HTMLPreformatted">exists Bus() </p><p><span class="Strong">At least one red Bus</span></p><p class="HTMLPreformatted">exists Bus(color == "red") </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">// brackets are optional:</p><p class="HTMLPreformatted">exists ( Bus(color == "red", number == 42) ) </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">// "exists" with nested infix and,</p><p class="HTMLPreformatted">// brackets are required:</p><p class="HTMLPreformatted">exists ( Bus(color == "red") and</p><p class="HTMLPreformatted">Bus(color == "blue") )</p><h2 class="Heading2">Advanced conditional elements</h2><h3 class="Heading3">Conditional Element forall</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_6.png" class="img_16" /></p><p>The Conditional Element forall completes the First Order Logic support in Drools. The Conditional Element forall evaluates to true when all facts that match the first pattern match all the remaining patterns. Example:</p><p class="HTMLPreformatted">rule "All English buses are red"</p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; forall( $bus : Bus( type == 'english')</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; Bus( this == $bus, color = 'red' ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;  // all English buses are red</p><p class="HTMLPreformatted">end </p><p>In the above rule, we "select" all Bus objects whose type is "english". Then, for each fact that matches this pattern we evaluate the following patterns and if they match, the forall CE will evaluate to true.</p><p>To state that all facts of a given type in the working memory must match a set of constraints, forall can be written with a single pattern for simplicity. Example:</p><p><span class="Strong">Single Pattern Forall</span></p><p class="HTMLPreformatted">rule "All Buses are Red" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; forall( Bus( color == 'red' ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // all Bus facts are red</p><p class="HTMLPreformatted">end </p><p>Another example shows multiple patterns inside the forall:</p><p><span class="Strong">Multi-Pattern Forall</span></p><p class="HTMLPreformatted">rule "all employees have health and dental care programs"</p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; forall( $emp : Employee()</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; HealthCare( employee == $emp ) </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; DentalCare( employee == $emp )</p><p class="HTMLPreformatted">)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // all employees have health and dental care</p><p class="HTMLPreformatted">end </p><p>Forall can be nested inside other CEs. For instance, forall can be used inside a not CE. Note that only single patterns have optional parentheses, so that with a nested forall parentheses must be used:</p><p><span class="Strong">Combining Forall with Not CE</span></p><p class="HTMLPreformatted">rule "not all employees have health and dental care" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; not ( forall( $emp : Employee()</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; HealthCare( employee == $emp ) </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; DentalCare( employee == $emp ) )</p><p class="HTMLPreformatted">)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160;&#160; // not all employees have health and dental care</p><p class="HTMLPreformatted">end </p><p>As a side note, <span class="HTMLCode_1">forall( p1 p2 p3...)</span> is equivalent to writing:</p><p><span class="HTMLCode_1">not(p1 and not(and p2 p3...)) </span></p><p>Also, it is important to note that forall is a scope delimiter. Therefore, it can use any previously bound variable, but no variable bound inside it will be available for use outside of it.</p><h3 class="Heading3">Conditional Element from</h3><p><br /><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_7.png" class="img_17" /></p><p>The Conditional Element from enables users to specify an arbitrary source for data to be matched by LHS patterns. This allows the engine to reason over data not in the Working Memory. The data source could be a sub-field on a bound variable or the results of a method call. It is a powerful construction that allows out of the box integration with other application components and frameworks. One common example is the integration with data retrieved on-demand from databases using hibernate named queries.</p><p>The expression used to define the object source is any expression that follows regular MVEL syntax. Therefore, it allows you to easily use object property navigation, execute method calls and access maps and collections elements.</p><p>Here is a simple example of reasoning and binding on another pattern sub-field:</p><p class="HTMLPreformatted">rule "validate zipcode" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; Person( $personAddress : address )</p><p class="HTMLPreformatted">&#160;&#160; Address( zipcode == "23920W") from $personAddress </p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // zip code is ok</p><p class="HTMLPreformatted">end </p><p>With all the flexibility from the new expressiveness in the Drools engine you can slice and dice this problem many ways. This is the same but shows how you can use a graph notation with the 'from':</p><p class="HTMLPreformatted">rule "validate zipcode" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person( )</p><p class="HTMLPreformatted">&#160;&#160; $a : Address( zipcode == "23920W") from $p.address </p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // zip code is ok</p><p class="HTMLPreformatted">end </p><p><br />Previous examples were evaluations using a single pattern. The CE from also support object sources that return a collection of objects. In that case, from will iterate over all objects in the collection and try to match each of them individually. For instance, if we want a rule that applies 10% discount to each item in an order, we could do:</p><p class="HTMLPreformatted">rule "apply 10% discount to all items over US$ 100,00 in an order" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $order : Order()</p><p class="HTMLPreformatted">&#160;&#160; $item: OrderItem( value &gt; 100 ) from $order.items </p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // apply discount to $item</p><p class="HTMLPreformatted">end </p><p>The above example will cause the rule to fire once for each item whose value is greater than 100 for each given order.</p><p>You must take caution, however, when using from, especially in conjunction with the lock-on-active rule attribute as it may produce unexpected results. Consider the example provided earlier, but now slightly modified as follows:</p><p class="HTMLPreformatted">rule "Assign people in North Carolina (NC) to sales region 1" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person( )</p><p class="HTMLPreformatted">&#160;&#160; $a : Address( state == "NC") from $p.address </p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} // Assign person to sales region 1 in a modify block\</p><p class="HTMLPreformatted">end</p><p class="HTMLPreformatted">rule "Apply a discount to people in the city of Raleigh" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person( )</p><p class="HTMLPreformatted">&#160;&#160; $a : Address( city == "Raleigh") from $p.address </p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} // Apply discount to person in a modify block</p><p class="HTMLPreformatted">end </p><p>In the above example, persons in Raleigh, NC should be assigned to sales region 1 and receive a discount; i.e., you would expect both rules to activate and fire. Instead you will find that only the second rule fires.</p><p>If you were to turn on the audit log, you would also see that when the second rule fires, it deactivates the first rule. Since the rule attribute lock-on-active prevents a rule from creating new activations when a set of facts change, the first rule fails to reactivate. Though the set of facts have not changed, the use of from returns a new fact for all intents and purposes each time it is evaluated.</p><p>First, it's important to review why you would use the above pattern. You may have many rules across different rule-flow groups. When rules modify working memory and other rules downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated, the use of modify is critical. You don't, however, want other rules in the same rule-flow group to place activations on one another recursively. In this case, the no-loop attribute is ineffective, as it would only prevent a rule from activating itself recursively. Hence, you resort to lock-on-active.</p><p>There are several ways to address this issue:</p><ul class="ul_3"><li class="li_1"><p class="p_1">Avoid the use of from when you can assert all facts into working memory or use nested object references in your constraint expressions (shown below).</p></li><li class="li_1"><p class="p_1">Place the variable assigned used in the modify block as the last sentence in your condition (LHS).</p></li><li class="li_1"><p class="p_1">Avoid the use of lock-on-active when you can explicitly manage how rules within the same rule-flow group place activations on one another (explained below).</p></li></ul><p>The preferred solution is to minimize use of from when you can assert all your facts into working memory directly. In the example above, both the Person and Address instance can be asserted into working memory. In this case, because the graph is fairly simple, an even easier solution is to modify your rules as follows:</p><p class="HTMLPreformatted">rule "Assign people in North Carolina (NC) to sales region 1" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person(address.state == "NC" )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} // Assign person to sales region 1 in a modify block</p><p class="HTMLPreformatted">end</p><p class="HTMLPreformatted">rule "Apply a discount to people in the city of Raleigh" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person(address.city == "Raleigh" )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} //Apply discount to person in a modify block</p><p class="HTMLPreformatted">end </p><p>Now, you will find that both rules fire as expected. However, it is not always possible to access nested facts as above. Consider an example where a Person holds one or more Addresses and you wish to use an existential quantifier to match people with at least one address that meets certain conditions. In this case, you would have to resort to the use of from to reason over the collection.</p><p>There are several ways to use from to achieve this and not all of them exhibit an issue with the use of<br />lock-on-active. For example, the following use of from causes both rules to fire as expected:</p><p class="HTMLPreformatted">rule "Assign people in North Carolina (NC) to sales region 1" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person($addresses : addresses)</p><p class="HTMLPreformatted">&#160;&#160; exists (Address(state == "NC") from $addresses)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} // Assign person to sales region 1 in a modify block</p><p class="HTMLPreformatted">end </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">rule "Apply a discount to people in the city of Raleigh" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $p : Person($addresses : addresses)</p><p class="HTMLPreformatted">&#160;&#160; exists (Address(city == "Raleigh") from $addresses)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($p) {} // Apply discount to person in a modify block</p><p class="HTMLPreformatted">end </p><p>However, the following slightly different approach does exhibit the problem:</p><p class="HTMLPreformatted">rule "Assign people in North Carolina (NC) to sales region 1" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $assessment : Assessment()</p><p class="HTMLPreformatted">&#160;&#160; $p : Person()</p><p class="HTMLPreformatted">&#160;&#160; $addresses : List() from $p.addresses</p><p class="HTMLPreformatted">&#160;&#160; exists (Address( state == "NC") from $addresses)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($assessment) {} // Modify assessment in a modify block</p><p class="HTMLPreformatted">end</p><p class="HTMLPreformatted">rule "Apply a discount to people in the city of Raleigh" </p><p class="HTMLPreformatted">ruleflow-group "test"</p><p class="HTMLPreformatted">lock-on-active true </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $assessment : Assessment()</p><p class="HTMLPreformatted">&#160;&#160; $p : Person()</p><p class="HTMLPreformatted">&#160;&#160; $addresses : List() from $p.addresses</p><p class="HTMLPreformatted">&#160;&#160; exists (Address( city == "Raleigh") from $addresses)</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; modify ($assessment) {} // Modify assessment in a modify block</p><p class="HTMLPreformatted">end </p><p>In the above example, the $addresses variable is returned from the use of from. The example also introduces a new object, assessment, to highlight one possible solution in this case. If the $assessment variable assigned in the condition (LHS) is moved to the last condition in each rule, both rules fire as expected.</p><p>Though the above examples demonstrate how to combine the use of from with lock-on-active where no loss of rule activations occurs, they carry the drawback of placing a dependency on the order of conditions on the LHS. In addition, the solutions present greater complexity for the rule author in terms of keeping track of which conditions may create issues.</p><p>A better alternative is to assert more facts into working memory. In this case, a person's addresses may be asserted into working memory and the use of from would not be necessary.</p><p>There are cases, however, where asserting all data into working memory is not practical and we need to find other solutions. Another option is to reevaluate the need for lock-on-active. An alternative to lock-on-active is to directly manage how rules within the same rule-flow group activate one another by including conditions in each rule that prevent rules from activating each other recursively when working memory is modified. For example, in the case above where a discount is applied to citizens of Raleigh, a condition may be added to the rule that checks whether the discount has already been applied. If so, the rule does not activate.</p><h3 class="Heading3">Conditional Element collect</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_8.png" class="img_18" /><br />The Conditional Element collect allows rules to reason over a collection of objects obtained from the given source or from the working memory. In First Order Logic terms this is the cardinality quantifier. A simple example:</p><p class="HTMLPreformatted">import java.util.ArrayList </p><p class="HTMLPreformatted">rule "Raise priority if system has more than 3 pending alarms"</p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $system : System()</p><p class="HTMLPreformatted">&#160;&#160; $alarms : ArrayList( size &gt;= 3 )</p><p class="HTMLPreformatted">&#160;&#160; from collect(Alarm(system == $system, status == 'pending'))</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // Raise priority, because system $system has</p><p class="HTMLPreformatted">&#160;&#160; // 3 or more alarms pending. The pending alarms</p><p class="HTMLPreformatted">&#160;&#160; // are $alarms.</p><p class="HTMLPreformatted">end </p><p>In the above example, the rule will look for all pending alarms in the working memory for each given system and group them in ArrayLists. If 3 or more alarms are found for a given system, the rule will fire.</p><p>The result pattern of collect can be any concrete class that implements the java.util.Collection interface and provides a default no-arg public constructor. This means that you can use Java collections like ArrayList, LinkedList, HashSet, etc., or your own class, as long as it implements the java.util.Collection interface and provide a default no-arg public constructor.</p><p>Both source and result patterns can be constrained as any other pattern.</p><p>Variables bound before the collect CE are in the scope of both source and result patterns and therefore you can use them to constrain both your source and result patterns. But note that collect is a scope delimiter for bindings, so that any binding made inside of it is not available for use outside of it.</p><p>Collect accepts nested from CEs. The following example is a valid use of "collect":</p><p class="HTMLPreformatted">import java.util.LinkedList; </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">rule "Send a message to all mothers" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $town : Town( name == 'Paris' )</p><p class="HTMLPreformatted">&#160;&#160; $mothers : LinkedList()</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; from collect( Person( gender == 'F', children &gt; 0 )</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; from $town.getPeople()</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // send a message to all mothers</p><p class="HTMLPreformatted">end </p><h3 class="Heading3">Conditional Element accumulate</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_9.png" class="img_19" /><br />The Conditional Element accumulate is a more flexible and powerful form of collect, in the sense that it can be used to do what collect does and also achieve results that the CE collect is not capable of achieving.</p><p>Accumulate allows a rule to iterate over a collection of objects, executing custom actions for each of the elements, and at the end, it returns a result object.</p><p>Accumulate supports both the use of pre-defined accumulate functions, or the use of inline custom code. Inline custom code should be avoided though, as it is harder for rule authors to maintain, and frequently leads to code duplication. Accumulate functions are easier to test and reuse.</p><p>The Accumulate CE also supports multiple different syntaxes. The preferred syntax is the top level accumulate, as noted bellow, but all other syntaxes are supported for backward compatibility.</p><h4 class="Heading4">Accumulate CE (preferred syntax)</h4><p>The top level accumulate syntax is the most compact and flexible syntax. The simplified syntax is as follows:</p><p class="HTMLPreformatted">accumulate( &lt;source pattern&gt;; &lt;functions&gt; [;&lt;constraints&gt;] )</p><p>For instance, a rule to calculate the minimum, maximum and average temperature reading for a given sensor and that raises an alarm if the minimum temperature is under 20C degrees and the average is over 70C degrees could be written in the following way, using Accumulate:</p><p><span class="Strong">Note</span></p><p>The DRL language defines "acc" as a synonym of "accumulate". The author might prefer to use "acc" as a less verbose keyword or the full keyword "accumulate" for legibility.</p><p class="HTMLPreformatted">rule "Raise alarm"</p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $s : Sensor()</p><p class="HTMLPreformatted">&#160;&#160; accumulate( Reading( sensor == $s, $temp : temperature );</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; $min : min( $temp ),</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; $max : max( $temp ),</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; $avg : average( $temp );</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; $min &lt; 20, $avg &gt; 70 )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // raise the alarm</p><p class="HTMLPreformatted">end </p><p>In the above example, min, max and average are Accumulate Functions and will calculate the minimum, maximum and average temperature values over all the readings for each sensor. <br />Drools ships with several built-in accumulate functions, including:</p><ul class="ul_3"><li class="li_1"><p class="p_1">average</p></li><li class="li_1"><p class="p_1">min</p></li><li class="li_1"><p class="p_1">max</p></li><li class="li_1"><p class="p_1">count</p></li><li class="li_1"><p class="p_1">sum</p></li><li class="li_1"><p class="p_1">collectList</p></li><li class="li_1"><p class="p_1">collectSet</p></li></ul><p>These common functions accept any expression as input. For instance, if someone wants to calculate the average profit on all items of an order, a rule could be written using the average function:</p><p class="HTMLPreformatted">rule "Average profit" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $order : Order()</p><p class="HTMLPreformatted">&#160;&#160; accumulate( OrderItem( order == $order, $cost : cost, $price : price );</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; $avgProfit : average( 1 - $cost / $price ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // average profit for $order is $avgProfit</p><p class="HTMLPreformatted">end </p><p>Accumulate Functions are all pluggable. That means that if needed, custom, domain specific functions can easily be added to the engine and rules can start to use them without any restrictions. To implement a new Accumulate Function all one needs to do is to create a Java class that implements the org.drools.core.runtime.rule.TypedAccumulateFunction interface. As an example of an Accumulate Function implementation, the following is the implementation of the average function:</p><p class="HTMLPreformatted">/**</p><p class="HTMLPreformatted">An implementation of an accumulator capable of calculating average values</p><p class="HTMLPreformatted">*/</p><p class="HTMLPreformatted">public class AverageAccumulateFunction implements org.drools.core.runtime.rule.TypedAccumulateFunction {</p><p class="HTMLPreformatted">&#160;&#160; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; public void writeExternal(ObjectOutput out) throws IOException {</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; public static class AverageData implements Externalizable {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; public int count = 0;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; public double total = 0; </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; public AverageData() {} </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; count= in.readInt();</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; total= in.readDouble();</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; public void writeExternal(ObjectOutput out) throws IOException {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; out.writeInt(count);</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; out.writeDouble(total);</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; }</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; * @see org.drools.base.accumulators.AccumulateFunction#createContext()</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public Serializable createContext() {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; return new AverageData();</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; * @see org.drools.core.base.accumulators.AccumulateFunction#init(java.lang.Object)</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public void init(Serializable context) throws Exception { AverageData data = (AverageData) context;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.count = 0;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.total = 0;</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; * @see org.drools.core.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, ja</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public void accumulate(Serializable context, Object value) {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; AverageData data = (AverageData) context;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.count++;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.total += ((Number) value).doubleValue();</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; * @see org.drools.core.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public void reverse(Serializable context, Object value) throws Exception { </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; AverageData data = (AverageData) context; </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.count--;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; data.total -= ((Number) value).doubleValue();</p><p class="HTMLPreformatted">&#160;&#160; } </p><p class="HTMLPreformatted">&#160;</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; * @see org.drools.core.base.accumulators.AccumulateFunction#getResult(java.lang.Object)</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public Object getResult(Serializable context) throws Exception { </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; AverageData data = (AverageData) context;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; return new Double( data.count == 0 ? 0 : data.total / data.count );&#160; </p><p class="HTMLPreformatted">&#160;&#160; }</p><p class="HTMLPreformatted">&#160;&#160; /* (non-Javadoc)</p><p class="HTMLPreformatted">&#160;&#160; (@see org.drools.core.base.accumulators.AccumulateFunction#supportsReverse()</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public boolean supportsReverse() {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; return true;</p><p class="HTMLPreformatted">&#160;&#160; }</p><p class="HTMLPreformatted">&#160;&#160; /**</p><p class="HTMLPreformatted">&#160;&#160; {@inheritDoc}</p><p class="HTMLPreformatted">&#160;&#160; */</p><p class="HTMLPreformatted">&#160;&#160; public Class&lt; ? &gt; getResultType() {</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; return Number.class;</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; }</p><p class="HTMLPreformatted">&#160;&#160; } </p><p>The code for the function is very simple, as we could expect, as all the "dirty" integration work is done by the engine. Finally, to use the function in the rules, the author can import it using the "import accumulate" statement:</p><p class="HTMLPreformatted">import accumulate &lt;class_name&gt; &lt;function_name&gt; </p><p>For instance, if one implements the class some.package.VarianceFunction function that implements the variance function and wants to use it in the rules, he would do the following:</p><p>Example 7.77. Example of importing and using the custom "variance" accumulate function</p><p class="HTMLPreformatted">import accumulate some.package.VarianceFunction variance </p><p class="HTMLPreformatted">rule "Calculate Variance"</p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; accumulate( Test( $s : score ), $v : variance( $s ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // the variance of the test scores is $v</p><p class="HTMLPreformatted">end </p><p><span class="Strong">Note</span></p><p>The built in functions (sum, average, etc) are imported automatically by the engine. Only user- defined custom accumulate functions need to be explicitly imported.</p><p><span class="Strong">Note</span></p><p>For backward compatibility, Drools still supports the configuration of accumulate functions through configuration files and system properties, but this is a deprecated method. In order to configure the variance function from the previous example using the configuration file or system property, the user would set a property like this: <br />drools.accumulate.function.variance = some.package.VarianceFunction</p><p>Please note that "drools.accumulate.function." is a prefix that must always be used, "variance" is how the function will be used in the drl files, and "some.package.VarianceFunction" is the fully qualified name of the class that implements the function behavior.</p><h4 class="Heading4">Alternate Syntax: single function with return type</h4><p>The accumulate syntax evolved over time with the goal of becoming more compact and expressive. Nevertheless, Drools still supports previous syntaxes for backward compatibility purposes.</p><p>In case the rule is using a single accumulate function on a given accumulate, the author may add a pattern for the result object and use the "from" keyword to link it to the accumulate result. Example: a rule to apply a 10% discount on orders over $100 could be written in the following way:</p><p class="HTMLPreformatted">rule "Apply 10% discount to orders over US$ 100,00" when</p><p class="HTMLPreformatted">&#160;&#160; $order : Order()</p><p class="HTMLPreformatted">&#160;&#160; $total : Number( doubleValue &gt; 100 )</p><p class="HTMLPreformatted">&#160; &#160;&#160;&#160; from accumulate( OrderItem( order == $order, $value : value ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; sum( $value ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; # apply discount to $order</p><p class="HTMLPreformatted">end </p><p>In the above example, the accumulate element is using only one function (sum), and so, the rules author opted to explicitly write a pattern for the result type of the accumulate function (Number) and write the constraints inside it. There are no problems in using this syntax over the compact syntax presented before, except that is is a bit more verbose. Also note that it is not allowed to use both the return type and the functions binding in the same accumulate statement.</p><h4 class="Heading4">Accumulate with inline custom code</h4><p><span class="Strong">Warning</span><br />The use of accumulate with inline custom code is not a good practice for several reasons, including difficulties on maintaining and testing rules that use them, as well as the inability of reusing that code. Implementing your own accumulate functions is very simple and straightforward, they are easy to unit test and to use. This form of accumulate is supported for backward compatibility only.</p><p>Another possible syntax for the accumulate is to define inline custom code, instead of using accumulate functions. As noted on the previous warned, this is discouraged though for the stated reasons. <br />The general syntax of the accumulate CE with inline custom code is:</p><p class="HTMLPreformatted">&lt;result pattern&gt; from accumulate( &lt;source pattern&gt;,</p><p class="HTMLPreformatted">&#160;&#160; init( &lt;init code&gt; ), </p><p class="HTMLPreformatted">&#160;&#160; action( &lt;action code&gt; ), </p><p class="HTMLPreformatted">&#160;&#160; reverse( &lt;reverse code&gt; ),</p><p class="HTMLPreformatted">&#160;&#160; result( &lt;result expression&gt; ) ) </p><p>The meaning of each of the elements is the following:</p><ul class="ul_3"><li class="li_1"><p class="p_1">&lt;source pattern&gt;: the source pattern is a regular pattern that the engine will try to match against each of the source objects.</p></li><li class="li_1"><p class="p_1">&lt;init code&gt;: this is a semantic block of code in the selected dialect that will be executed once for each tuple, before iterating over the source objects.</p></li><li class="li_1"><p class="p_1">&lt;action code&gt;: this is a semantic block of code in the selected dialect that will be executed for each of the source objects.</p></li><li class="li_1"><p class="p_1">&lt;reverse code&gt;: this is an optional semantic block of code in the selected dialect that if present will be executed for each source object that no longer matches the source pattern. The objective of this code block is to undo any calculation done in the &lt;action code&gt; block, so that the engine can do decremental calculation when a source object is modified or deleted, hugely improving performance of these operations.</p></li><li class="li_1"><p class="p_1">&lt;result expression&gt;: this is a semantic expression in the selected dialect that is executed after all source objects are iterated.</p></li><li class="li_1"><p class="p_1">&lt;result pattern&gt;: this is a regular pattern that the engine tries to match against the object returned from the</p></li><li class="li_1"><p class="p_1">&lt;result expression&gt;. If it matches, the accumulate conditional element evaluates to true and the engine proceeds with the evaluation of the next CE in the rule. If it does not matches, the accumulate CE evaluates to false and the engine stops evaluating CEs for that rule.</p></li></ul><p>It is easier to understand if we look at an example:</p><p class="HTMLPreformatted">rule "Apply 10% discount to orders over US$ 100,00" </p><p class="HTMLPreformatted">when</p><p class="HTMLPreformatted">&#160;&#160; $order : Order()</p><p class="HTMLPreformatted">&#160;&#160; $total : Number( doubleValue &gt; 100 )</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; from accumulate( OrderItem( order == $order, $value : value ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; init( double total = 0; ),</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; action( total += $value; ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; reverse( total -= $value; ),</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result( total ) )</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; # apply discount to $order</p><p class="HTMLPreformatted">end </p><p>In the above example, for each Order in the Working Memory, the engine will execute the init code initializing the total variable to zero. Then it will iterate over all OrderItem objects for that order, executing the action for each one (in the example, it will sum the value of all items into the total variable). After iterating over all OrderItem objects, it will return the value corresponding to the result expression (in the above example, the value of variable total). Finally, the engine will try to match the result with the Number pattern, and if the double value is greater than 100, the rule will fire.</p><p>The example used Java as the semantic dialect, and as such, note that the usage of the semicolon as statement delimiter is mandatory in the init, action and reverse code blocks. The result is an expression and, as such, it does not admit ';'. If the user uses any other dialect, he must comply to that dialect's specific syntax.</p><p>As mentioned before, the reverse code is optional, but it is strongly recommended that the user writes it in order to benefit from the improved performance on update and delete.</p><p>The accumulate CE can be used to execute any action on source objects. The following example instantiates and populates a custom object:</p><p class="HTMLPreformatted">rule "Accumulate using custom objects" when</p><p class="HTMLPreformatted">&#160;&#160; $person: Person( $likes : likes )</p><p class="HTMLPreformatted">&#160;&#160; $cheesery : Cheesery( totalAmount &gt; 100 )</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160; from accumulate(</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $cheese : Cheese( type == $likes ),</p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; init( Cheesery cheesery = new Cheesery(); ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; action( cheesery.addCheese( $cheese ); ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; reverse( cheesery.removeCheese( $cheese ); ), </p><p class="HTMLPreformatted">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result( cheesery ) );</p><p class="HTMLPreformatted">then</p><p class="HTMLPreformatted">&#160;&#160; // do something</p><p class="HTMLPreformatted">end </p><h3 class="Heading3">Conditional Element eval</h3><p><img src="../../../../../Resources/Images/Rule+Syntax+and+Construction/Basic conditional elements_10.png" class="img_20" /><br /><br />The conditional element eval is essentially a catch-all which allows any semantic code (that returns a primitive boolean) to be executed. This code can refer to variables that were bound in the LHS of the rule, and functions in the rule package. Overuse of eval reduces the declarativeness of your rules and can result in a poorly performing engine. While eval can be used anywhere in the patterns, the best practice is to add it as the last conditional element in the LHS of a rule.</p><p>Evals cannot be indexed and thus are not as efficient as Field Constraints. However this makes them ideal for being used when functions return values that change over time, which is not allowed within Field Constraints.</p><p>For folks who are familiar with Drools 2.x lineage, the old Drools parameter and condition tags are equivalent to binding a variable to an appropriate type, and then using it in an eval node.</p><p class="HTMLPreformatted">p1 : Parameter()</p><p class="HTMLPreformatted">p2 : Parameter()</p><p class="HTMLPreformatted">eval( p1.getList().containsKey( p2.getItem() ) ) </p><p class="HTMLPreformatted">p1 : Parameter()</p><p class="HTMLPreformatted">p2 : Parameter()</p><p class="HTMLPreformatted">// call function isValid in the LHS</p><p class="HTMLPreformatted">eval( isValid( p1, p2 ) ) </p></body>
</html>